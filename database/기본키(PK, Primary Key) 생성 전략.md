# 기본키(PK, Primary Key) 생성 전략
- 기본키를 생성하는 전략은 크게 다음 4가지 방식이 존재하며, 각 방식의 장단점을 이해하고 각 서비스의 특성에 맞게 적절히 선택할 수 있어야 한다.

---

### DB Auto Increment 방식
- 계속 증가하기 때문에 새로운 데이터가 추가되더라도 인덱스 재정렬이 자주 일어나지 않음.
- 분산 데이터베이스 환경에서 PK가 중복될 수 있기 때문에 식별자의 유일성이 보장되지 않는다.
  - 여러 샤드에서 동일한 PK를 가지는 상황이 존재할 수 있음.
- 클라이언트 측에 노출하면 그 자체로 보안 문제
  - 데이터 갯수 또는 특정 시점의 식별자 예측
  - 예) 방금 가입했더니 user_id 가 1000 이면? => 1000명의 사용자가 있다는 사실을 유추할 수 있음
- 대신, 이 전략은 간단하기 때문에 다음 상황에서 유리할 수 있다.
  - 보안적인 문제를 크게 고려하지 않는 상황
  - 단일 DB를 사용하거나, 애플리케이션에서 PK 의 중복을 직접 구분하는 상황
- 보안적인 문제가 걱정된다면
  - PK 는 데이터베이스 내에서의 식별자로만 사용
  - 애플리케이션에서의 식별자를 위해 별도 유니크 인덱스를 생성할 수도 있다.
  - 예)
    - PK = id(DB auto_increment)
    - unique index = article_id(UUID 등)
    - Client 는 article_id 만 식별자로서 노출 및 사용
  - 하지만 별도의 유니크 인덱스를 사용해서 접근하면 Secondary Index 를 사용하므로 PK를 통한 접근보다 조회 성능이 증가한다.
    - Primary Key Index = Clustered Index 사용: Clustered Index 를 통해 바로 데이터에 접근하게 됨
    - Unique Index = Secondary Index 사용: Secondary Index 로 포인터를 찾은 후 Clustered Index 를 통해 데이터에 접근하게 됨 

---

### 유니크 문자열 또는 숫자
- UUID 또는 난수를 생성하여 PK 를 지정할 수 있다.
  - 정렬 데이터가 아니라 랜덤 데이터를 삽입하는 것이다.
  - 키 생성 방식이 간단하다.
- 하지만 랜덤 데이터로 인해 성능저하가 발생할 수 있다.
  - Clustered Index 는 항상 정렬된 상태를 유지한다.
  - 데이터 삽입이 필요한 인덱스 페이지가 가득찼다면, B+Tree 재구성 및 페이지 분할로 디스크 I/O 증가
  - PK 를 이용한 범위 조회가 필요하다면, 디스크에서 랜덤 I/O가 발생하기 때문에 순차 I/O 보다 성능이 저하된다.

---

### 유니크 정렬 문자열
- 분산 환경에 대한 PK 중복 문제 해결
- 보안 문제 해결
- 랜덤 데이터에 의한 성능 문제 해결
  - 시간정보가 포함되어, 순차성이 생긴다.
- UUID v7, ULID 등의 알고리즘
  - 일반적으로 알려진 알고리즘은 128 비트를 사용한다.
- 데이터 크기에 따라 공간 및 성능 효율이 달라진다.
  - Clustered Index 는 PK 를 기준으로 만들어진다.
  - Secondary Index 는 데이터에 접근할 수 있는 포인터를 가진다.
    - 즉 PK 를 가지고 있으며, 데이터에 접근할 때는 PK로 Clustered Index 를 통해 접근하여 페이지에 접근한다.
  - 각 행의 크기가 커질 수록, 리프노드의 크기가 커진다. 각 노드(페이지)에서 저장할 수 있는 인덱스 항목 개수가 줄어든다.
  - 비교연산에 의한 정렬/조회를 할 때 페이지에 접근할 일이 많은데, 접근하게 되는 페이지가 늘어나게 된다.
  - 이 과정에서 페이지 I/O(Page Access)가 증가하고, 디스크 I/O 및 메모리 사용량이 증가하여 성능이 저하하게 된다.

---

### 유니크 정렬 숫자
- 분산 환경에 대한 PK 중복 문제 해결
- 보안 문제 해결
- 랜덤 데이터에 의한 성능 문제 해결
- Snowflake, TSID 등의 알고리즘
  - 64 비트를 사용한다.
  - 정렬을 위해 타임스탬프를 나타내는 비트 수의 제한으로 키 생성을 위한 시간적인 한계가 있을 수 있다.
  - 문자열 알고리즘에서도 동일한 문제가 있을 수 있으나, 비트수가 많을 수록 제한이 덜 할 수 있다.
- 앞서 살펴본 문자열 방식보다 적은 공간을 사용한다.

---
